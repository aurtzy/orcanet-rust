# Market Client
- **main**
	- parse cmd args, init a new user instance, store market port, setup (tx, rx) [trnasmitter and reciever ends of multi-producer channel for async msg passing], and (m_state_tx, m_state_rx) [single use channel for sending single sg from one task to another through ActorMarketState channel (<--pub enum in util)]
		- **CHECK cli struct notes in cli.rs**
		- #[arg] -> attr from clap crate and is cli arg
			- short = short version of argument (-p)
			- long = long (--port)
			- default = default
		- takes port,
			- what local market server is listening on and client to connect to
		- username, 
			- prob remove this cuz sha256 ids made from user pub keys
		- price, 
			- price / mb, (can prob change based on file size chunks)
		- id, 
			- ID of peer, generated if n/a
		- client_port and ip
			- where other customers connect to
	- created scoped thread (spawn 2 threads concurrently)
		- *ensures any ref created within the scope can't outlive scope itself (no data races/mem safety issues)*
		- Thread 1
			- Inits Actor with user and rx channels
			- init new runtime, blocking on async block where it connects to market server with init client
			- on init, m_state_tx can send a msg with connection and run actor main logic
			- if init or state transmission fails, return ok at the end
		- Thread 2
			- wait for actor client to connect to market server
			- blocks until msg received for connection or not

- **actor
	- pub struct that takes in User and receiver msgs
	- '*run*'
		- take ownership of 'self' and mutable client to send and receieve data/commands
		- enters loop to continuously receieve cmds from receiver channel
		- *cmd processing*
				- #[derive()] used on enum commands
					- macro to tell compiler to derive implementations for listed traits and behaviors automatically
					- debug - allow enum to be printed
					- clone - clone instances of enum
					- partialeq and eq - instances of enum compared for equality
					- enumString - conversion of strings to enum variants and vice versa
			- quit
			- help
			- register file
				- takes file hash and user and returns msg
			- check holders 
				- check holders of a file with a given hash
	- '*message*'
		- msg struct takes in string and converts to lowercase
		- into_cmd attempts to parse msg string into cmd from: 
		- '*TryFrom for command*'
			- parse content of msg into a command
			- split msg str into words and takes it as a cmd name and extract args based on cmd
			- matches cmd to one of the options
		- '*display for msg*'
			- impl display trait for msg and specifiy how message should be formated

- **util**
	- loopback addr (local machine) and default market server port number
	- '*start main loop*'
		- (tx) takes unbounded channel sender for sending msgs
			- *unbounded channel sender* - send messages btwn asynch tasks running concurrently
		- continuously read line and turn msg into command
			- if yes, send cmd through 'tx'
		- keep going til EOF or interrupt signal for 'quit' cmd or if error reading parsing input
	- '*initialize client*'
		- create an init 'marketClient' that connects to market server with GRPC
		- takes market port arg
		- build uri used for gRPC using loopback address and market port
		- then async connect to market server passing URI
	- '*actor market state*'
		- not connected/ connected
	- '*Prompt*'
		- >> used as cmd prompt to enter command

- **lib**
	- entry point for crate to encapsulate related functionality
	- specify compiler warnings 
		- warn if debug trait is not implemented for a type
		- warn if pub item is declared but never used
		- deny unsafe code
			- call unsafe functions or methods
			- access or modify static mut variables
			- implement unsafe traits, etc.
	- specify module declarations


# Market Server
- **Main**
	- creates instance for CLI parsing and MarketService (backend)
	- Server::builder() sets up gRPC server with 'MarketServer' and binds it to specific socket address
		- returns error if any server issues
- **CLI**
	- clap crate for parsing
	- Port from crate 
	- *CLI Struct*
		- #[derive()]implements debug and parser traits
		- #[command] author, version, about, long_about = None (<-- no extended description provided)
			- metadata about CLI
		- Port field (*defined as u16 in lib.rb*)
			- defaulted to 8080
- **lib**
	- same compiler attrs as **MarketClient**
	- *Port* = u16
	- modules cli and market_server
- **market_service**
	- Peer that starts as a DHT node with an IP address and Port (some fields might be allocated to the *peer nodes* team to get rid of some overhead)
	- *Imports*
		- std - sync, collections
		- market_porto_rpc file stuff
		- tonic
	- **DHT initialization will be using market_dht lib and then integrated into market_server**
	- *MarketService struct*
		- store: 'Arc<Mutex<MarketStore'
			- reference counted smart pointer (Arc) to thread safe mutex containing ***MarketStore*** (Hashmap<String, HashSet<User) 
	- *Market Trait implementation*
		- 'register file'
			- takes request with file information and locks 'store' mutex for exclusive access and inserts into store
			- stores file hash and userID associated with file
			- *returns* empty response if successful
		- 'check holders'
			- check for holders identified by file hash
			- takes request containing file hash and locks store mutex to retrieve holders of a file
			- *returns* response containing holders


 


# Market DHT
**CURRENT ISSUES:
- bootstrapping race condition somewhere
- quoram fails
- get_record succeeds for a created hash but crashes DHT server after
- nodes aren't storing information about each other's nodes (bootnodes) 

CUSTOM market DHT opposed to using IPFS-kad
- **command**
	- *imports*
		- std::nte::Ipv4Addr
		- anyhow::Result
		- cid::Cid
		- futures::channel::oneshot
		- libp2p::{multiaddr, peerid}
		- create::file::FileMetadata
	- *Type Definitions*
		- CommandCallback
			- tuple containing Command and 'oneshot::Sender' (single prod and consumer channel --> each channel instance transports only a single message) for sending result of command
		- CommandResult
			- representing result of a command where Result contains CommandOk
	- *CommandOk*
		- enum for a result of a command sent to DHT
			- Listen - return address of where peer is now listening
			- Bootstrap - return peerId from libp2p swarm bootstrap request and num_remaining (u32)
			- Dial - return peerId we successfully dialed
			- Register - return CID of file
			- GetFile - takes file_cid (file user requested), metadata of file, owner_peer id that we get record from
			- GetClosestPeers - takes CID of file user requests and list of closest peers
			- GetLocalPeerID - return local node's peer ID
	- ***NOTES:***
		- start_providing vs put_record or possible both depending peer nodes team implementation
		- chuck over file eventually
- **file**
	- utilities for handling files
	- *new_cidv0*
		- create new CIDv0 generated from file that's inserted
		- takes in:
			- data - byte slice for data 
			- return - 'result' containing CID or Error
	- *FileMetaData*
		- Struct 
			- #[derive()]
				- debug, clone, copy, partialEq, eq
				- *Serialize/Deserialize* - 'serde' crate and allows instances of struct to be de/serialized into formats like JSON
			- IPv4 address of peer storing file: Ipv4Addr
			- port on which peer is serving file: u16
			- price/mb: u64
		- Impl
			- constructors and getters
- **lib**
	- **NOTE: possibly add more extensions for more protocols later**
	- same compiler attrs plus a few more
	- export items from bridge and command for users and file


**MIGHT HAVE TO DO A RESET ON THE LAST 3 FILES**
- **DHT CLIENT**
	- import dependencies
	- *Dht Client*
		- Struct
			- #[derive()] debug
			- sender: Arc<MutexM<Sender<CommandCallback<
		- Impl
			- constructor
			- *listen_on*
				- async method that sends listening request to listen on given a MultiAddr
				- return CommandResult
			- *bootstrap*
				- **NOTE: This is most likely a source of problems**
				- async method to send bootstrap request to connect to user-provided bootnodes
				- takes an iterator that contains tuples of (PeerId, Multiaddr)
				- return result for success or failure
			- *dial*
				- connect to specific peer given PeerId and Multiaddr
				- oneshot channel is created for receiving result
				- command, peerid, and addr sent through DHT server
				- await for operation to finish 
				- return Command success or failure
			- *register*
				- register file metadata into DHT using CID and allows file to be seen by other peers on the network
				- convert file_cid to cid and send command to DHT server with file CID, IP, port, and price
				- await for operation to finish
				- return Command success or failure
			- *get_file*
				- get file metadata given CID with command to the DHT server
				- return Command success or failure
			- *get_closest_peers*
				- find closest peers given CID for content discovery
				- similar to get_file but a different command
			- *get_local_peer_id*
				- similar to ^^^^^ but different command
- **mod**
	- Bridge for Dht Client API with Dht Server
	- *Import dependencies
	- *bridge*
		- factory for creating DhtClient and DhtServer and establish connection
		- takes size cmd_buffer to determine how many commands server can buffer
		- returns tuple (DhtClient, DhtServer) containing init DHT client and server and will show error if needed
		- inits a 'swarm' instance with all configs needed 
			- new identity, tokio, tcp, dns, behavior, swarm config
		- create channel with sender/receiver for communication and inits Dht client/server with them
- **DHT SERVER**
	- **NOTE: PROB GONNA HAVE TO RESET THIS**
	- handles commands from client by directing it to actual [libp2p] swarm
	- *import dependencies*
	- *DhtServer Struct*
		- swarm<Behavior<MemoryStore< type - configured with DHT behavior using in-memory store
		- cmd_Receiver - used to receive cmds from clients ()
			- mpsc::Receiver<CommandCallBack< - mpsc = multi-producer, single-consumer (multiple clients send cmds to single server)
		- pending_queries - HashMap mapping queryId to CommandResultSender to keep track of DHT quereies 
		- pending_dials - similar to ^^^ but tracks ongoing direct connections to peers mapped by PeerId
		- pending_listeners - similar to ^^^ but tracks listeners waiting for specific events mapped by ListenerId
	- *impl DhtServer*
		- *constructor*
		- *run*
			- DHT server main loop until cmd receiver or swarm stops
			- async wait for cmds or events from swarm
		- *handle_swarm_event*
			- handle libp2p swarm events
			- matches different events and executes logic
			- **NOTE: BOOTSTRAP NOT WORKING AS INTENDED RN SO HOLD OFF ON THIS**
		- *handle_cmd*
			- handles cmds received from clients
			- process different types of cmds and executes logic
				- *Listen* - tell nodes to start listening on specified address
					- stores listenerID in pending_listeners map
				- *Bootstrap* - initiate bootstrap process for DHT
					- for each bootstrap node, add address to libp2p swarm 
					- stores queryID and sender channel in pending_query map 
				- *Dial* - establish connection with specific peer
					- add peer's address to Swarm to dial
					- store sender channel in pending_dials map
				- *Register* - store k,v pair in DHT
					- create record with CID, IP, port, and price/mb and try to store into DHT
					- stores queryID and sender channel into pending_queries 
				- *GetFile* - get value from DHT with key
					- makes key from given CID to get record
					- stores queryID and sender channel in pending_queries
				- *GetClosestPeers* - find closest to given key in DHT
					- makes key from CID and finds closest peers
					- stores queryID and sender channel in pending_queries
				- *GetLocalPeerId* 
					- get local peerID from Swarm and send back to caller through sender channel